\name{labels}

\alias{labels.default}
\alias{labels.data.frame}
\alias{labels<-}

\alias{as.labeled.data.frame}
\alias{as.labelled.data.frame}
\alias{is.labeled.data.frame}
\alias{is.labelled.data.frame}
\alias{[.labeled.data.frame}
\alias{subset.labeled.data.frame}
\alias{cbind.labeled.data.frame}
\alias{rbind.labeled.data.frame}

\title{
  Extract and Set Labels from / to Data Frames
}
\description{
  Labels can be stored to an attribute \code{"variable.labels"} using
  the assignment function. With the extractor function one can assess
  these labels. Usually, these labels are generated by
  \code{\link{read.spss}} in package \pkg{foreign}.
}
\usage{

\method{labels}{data.frame}(object, which = NULL, abbreviate = FALSE, ...)

## assign labels
labels(data, which = NULL) <- value

## check if data.frame is a special labeled.data.frame
is.labeled.data.frame(object)
## set as.labeled.data.frame
as.labeled.data.frame(object, ...)

## special functions for labeled.data.frame objects that keep the labels
\method{[}{labeled.data.frame}(x, ..., drop = FALSE)
\method{subset}{labeled.data.frame}(x, ...)
\method{cbind}{labeled.data.frame}(..., deparse.level = 1)
\method{rbind}{labeled.data.frame}(..., deparse.level = 1)
}

\arguments{
  \item{object}{
    a \code{data.frame} or \code{labeled.data.frame}. The former is
    usually a result from \code{\link{read.spss}} in package
    \pkg{foreign}, the latter results from adding labels in R or from a
    call to \code{as.labeled.data.frame}.
  }
  \item{data}{
    a \code{data.frame}, where labels should be added or altered.
  }
  \item{which}{
    either a number indicating the label to extract or a character
    string with the variable name for which the label should be
    extracted. One can also use a vector of numerics or character
    strings to extract mutiple labels. If \code{which} is \code{NULL}
    (default), all labels are returned.
  }
  \item{value}{
    a vector containing the labels (in the order of the variables). If
    which is given, only the corresponding subset is labeled. Note that
    all other labels contain the variable name as label afterwards.
  }
  \item{abbreviate}{
    logical (default: \code{FALSE}). If \code{TRUE} variable labels are
    abbreviated such that they remain unique. See
    \code{\link{abbreviate}} for details. Further arguments to
    \code{\link{abbreviate}} can be specified (see below).
  }
  \item{\dots}{
    further options passed to function \code{\link{abbreviate}} if argument
    \code{abbreviate = TRUE}.

    In \code{x[...]}, \dots can be used to specify indices for
    extraction. See \code{\link{[}} for details.
  }
  \item{x}{
    a \code{labeled.data.frame}.
  }
  \item{drop}{
    logical (default: FALSE). If \code{TRUE} the result is coerced to
    the lowest possible dimension (i.e. a vector in case of a single
    column) and labels might be dropped in this case.
  }
  \item{deparse.level}{
    see \code{\link{cbind}}.
  }
}
\details{
  One can set or extract labels from \code{\link{data.frame}} objects.
  If no labels are specified \code{labels(data)} returns the column
  names of the data frame. If labels are set (attached to a
  \code{data.frame}) the \code{data.frame} gets a special class
  \code{labeled.data.frame} with specific subset and combination
  functions.

  Using \code{abbreviate = TRUE}, all labels are abbreviated to (at
  least) 4 characters such that they are unique. Other minimal lengths
  can specified by setting \code{minlength} (see examples below).
}
\value{
  A named vector of variable labels is returned, where the names are
  the variable names.
}

\author{
  Benjamin Hofner
}
\note{
  Reordering of the data set does \bold{not} reorder the labels, in
  contrary, the labels are dropped in this case. New labels are always
  attached at the end of the label vector, see examples below.
}
\seealso{
  \code{\link{read.spss}} in package \pkg{foreign}
}
\examples{
data <- data.frame(a = 1:10, b = 10:1, c = rep(1, 10))
labels(data) <- c("a", "b", "c")
## one gets a named character vector of labels
labels(data)

## set labels for a and b only
labels(data, which = c("a", "b")) <- c("x", "y")
labels(data)

## reset labels:
labels(data) <- NULL
labels(data)

## set label for a only and use default for other labels:
labels(data, which = "a") <- "x"
labels(data)

## attach label for new variable:
data2 <- data
data2$z <- rep(2, 10)
labels(data2)    # no label for z
labels(data2, which = "z") <- "new_label"
labels(data2)
## Note: labels are always attached at the end of the vector

## attach long labels to data
labels(data) <- c("This is a long label", "This is another long label",
                  "This also")
labels(data)
labels(data, abbreviate = TRUE, minlength = 10)
}

\keyword{methods}
